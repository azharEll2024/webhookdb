# frozen_string_literal: true

require "webhookdb/id"
require "webhookdb/postgres/model"
require "sequel/plugins/soft_deletes"

class Webhookdb::ServiceIntegration < Webhookdb::Postgres::Model(:service_integrations)
  plugin :timestamps
  plugin :soft_deletes

  many_to_one :organization, class: "Webhookdb::Organization"
  one_to_many :webhook_subscriptions

  def process_state_change(field, value)
    return Webhookdb::Services.service_instance(self).process_state_change(field, value)
  end

  def calculate_create_state_machine
    return Webhookdb::Services.service_instance(self).calculate_create_state_machine
  end

  def calculate_backfill_state_machine
    return Webhookdb::Services.service_instance(self).calculate_backfill_state_machine
  end

  def can_be_modified_by?(customer)
    return customer.verified_member_of?(self.organization)
  end

  def service_instance
    return Webhookdb::Services.service_instance(self)
  end

  # WEBHOOK SUBSCRIPTION

  def all_webhook_subs
    return self.webhook_subscriptions + self.organization.webhook_subscriptions
  end

  # SUBSCRIPTION PERMISSIONS

  def plan_supports_integration?
    # if the sint's organization has an active subscription, return true
    return true if self.organization.active_subscription?
    # if there is no active subscription, check whether the integration is one of the first two
    # created by the organization
    limit = Webhookdb::Subscription.max_free_integrations
    free_integrations = Webhookdb::ServiceIntegration.
      where(organization: self.organization).order(:created_at, :id).limit(limit).all
    free_integrations.each do |sint|
      return true if sint.id == self.id
    end
    # if not, the integration is not supported
    return false
  end

  # STATS ON LOGGED WEBHOOKS
  VALID_STATS_FORMATS = ["table", "object"].freeze

  def stats(format)
    raise ArgumentError, "\"#{format}\" is not a valid format for webhook stats" unless format.in?(VALID_STATS_FORMATS)
    all_logged_webhooks = Webhookdb::LoggedWebhook.where(
      service_integration_opaque_id: self.opaque_id,
    ).where { inserted_at > 7.days.ago }

    no_logged_webhooks_msg = "We have no record of receiving webhooks for that integration in the past seven days."

    if all_logged_webhooks.empty?
      if format == "table"
        return {
          headers: ["Message"],
          rows: [[no_logged_webhooks_msg]],
        }
      end
      return no_logged_webhooks_msg
    end

    total_count = all_logged_webhooks.count
    rejected_count = all_logged_webhooks.where { response_status >= 400 }.count
    success_count = (total_count - rejected_count)
    rejected_percent = (rejected_count.to_f / total_count)
    success_percent = (success_count.to_f / total_count)

    # this "table" format is designed to make formatting the CLI output easier by returning data
    # in the form that our Go table formatting library requires
    if format == "table"
      return {
        headers: ["name", "value"],
        rows: [
          ["Total Webhooks Logged", total_count.to_s],
          ["Successful Webhooks", success_count.to_s],
          ["Percent Successful", "%.1f%%" % (success_percent * 100)],
          ["Rejected Webhooks", rejected_count.to_s],
          ["Percent Rejected", "%.1f%%" % (rejected_percent * 100)],
        ],
      }
    end

    return {
      total_count:,
      rejected_count:,
      success_count:,
      rejected_percent:,
      success_percent:,
    }
  end

  #
  # :Sequel Hooks:
  #

  def before_create
    self[:opaque_id] ||= Webhookdb::Id.new_opaque_id("svi")
  end

  # @!attribute table_name
  #   @return [String] Name of the table

  # @!attribute service_name
  #   @return [String] Lookup name of the service

  # @!attribute api_url
  #   @return [String] Root Url of the api to backfill from

  # @!attribute backfill_key
  #   @return [String] Key for backfilling.

  # @!attribute backfill_secret
  #   @return [String] Password/secret for backfilling.
end

# Table: service_integrations
# ---------------------------------------------------------------------------------------------
# Columns:
#  id                 | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at         | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at         | timestamp with time zone |
#  soft_deleted_at    | timestamp with time zone |
#  organization_id    | integer                  | NOT NULL
#  api_url            | text                     | NOT NULL DEFAULT ''::text
#  opaque_id          | text                     | NOT NULL
#  service_name       | text                     | NOT NULL
#  webhook_secret     | text                     | DEFAULT ''::text
#  table_name         | text                     | NOT NULL
#  backfill_key       | text                     | NOT NULL DEFAULT ''::text
#  backfill_secret    | text                     | NOT NULL DEFAULT ''::text
#  last_backfilled_at | timestamp with time zone |
# Indexes:
#  service_integrations_pkey          | PRIMARY KEY btree (id)
#  service_integrations_opaque_id_key | UNIQUE btree (opaque_id)
#  unique_tablename_in_org            | UNIQUE btree (organization_id, table_name)
# Foreign key constraints:
#  service_integrations_organization_id_fkey | (organization_id) REFERENCES organizations(id)
# ---------------------------------------------------------------------------------------------
